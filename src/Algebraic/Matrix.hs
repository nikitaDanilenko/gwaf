----------------------------------------------------------------------------------------------------
-- |
-- Module      :  Auxiliary.Matrix
-- Copyright   :  (c) Nikita Danilenko 2015
-- License     :  GPL Version 3
-- Maintainer  :  nikita.danilenko.is@gmail.com
-- Stability   :  experimental
-- Portability :  portable

-- This module contains an implementation of matrices as association lists of association lists.
-- The main idea behind the presented abstraction is that there are likely to be two different kinds
-- of association lists involved.
-- The outer association list type is intended to be queried directly,
-- while the inner type is largely used in set-like operations like unions.

{-# Language MultiParamTypeClasses, KindSignatures, ScopedTypeVariables, FlexibleInstances #-}

module Algebraic.Matrix (
  
  -- * Matrix data type

  ParaMatrix,
  Matrix,
  Proxy ( .. ),
  matrix,
  fromMat,
  fromMappings,
  toMat,

  -- * Auxiliary functions

  isEmptyMatrix,
  filterMatrix,
  removeZeroesMatrix,
  emptyMatrix,
  
  -- * Functor operations

  rowMapWithKey,
  rowMap,

  -- * Query

  (!!!),
  mAtZ,
  mAt,
  rowNumbers,
  rowDimension,
  
  -- * Vector-matrix multiplication

  vecMatMult,
  liftVecMatMult,
  (.**.),
--   (.++.),
  smultWithKeys,
  smultWithKey,
  HasHetVMM ( .. ),
  HasVMM

  ) where

import Data.Function                ( on )
import Data.Foldable                ( Foldable )
import qualified Data.Foldable as F ( all )
import Data.IntMap                  ( IntMap )
import Data.List                    ( intercalate, genericReplicate )
import GHC.TypeLits                 ( Nat, natVal, KnownNat )

import Algebraic.Semiring           ( MonoidA, (.+.), FindZero, isNotZero, zero, GroupA, inverseA,
                                      (.-.), MonoidM, (.*.), one, Semiring, FindOne )
import Algebraic.Vector             ( (*>), removeZeroes, unitVector )
import Auxiliary.AList              ( AList )
import Auxiliary.General            ( Key, Arc, Mat, (<.>), scaleLeft )
import Auxiliary.KeyedClasses       ( Lookup, maybeAt, KeyFunctor, fmapWithKey, KeyMaybeFunctor,
                                      ffilter )
import Auxiliary.Mapping            ( Mapping, MappingV, fromRow, toRow, keys, isEmpty, empty )
import Auxiliary.SafeArray          ( SafeArray )
import Auxiliary.SetOps             ( Intersectable, intersectionWith, intersectionWithKey,
                                      Unionable, unionWith, Complementable, differenceWith,
                                      differenceWith2, UnionableHom, SetOps, SetOpsHom,
                                      bigunionWith )
import Auxiliary.SetOpsInstances    ()

import Algebraic.Semiring

data Proxy (n :: Nat) = Proxy

-- | Matrix data type.
-- Both @o@ and @i@ are type constructors and serve as mnemonics for the __o__uter, respectively
-- __i__nner association list types.
-- 
-- The indended application is the following:
-- 
-- * Both @o@ and @i@ are instances of the 'Mapping' type class.
-- * The matrix rows are indexed with @[0 .. n-1]@ for some natural number /n/.
--   For every @i <- [0 .. n-1]@ the @i@-th entry in the outer mapping denotes the @i@-th row
--   of the matrix.
-- * The natural number denoting the number of rows is a type-level natural number.
--   In practical applications it is usually @'Proxy' n@, where @n@ is a numerical value
--   that is lifted to the type level by the GHC.
-- 
-- If the outer matrix layer is an instance of 'Lookup' and
-- the inner one is an instance of 'MappingV',
-- the matrix rows can be accessed using the function @('!!!')@.
-- The query function @('!!!')@ yields the empty row for every row index that is not filled.

newtype ParaMatrix rs o i a = ParaMatrix { matrix :: o (i a) }

-- | A more convenient notation for matrices.
-- A typical application is to define a matrix an then to supply the additional type information
-- like @m :: Matrix 10 IntMap AList (Number Integer)@.
-- Note that @10@ in the above context is in fact a type generated by GHCs ability to promote
-- natural numbers to the type level.

type Matrix rs o i a = ParaMatrix (Proxy rs) o i a

-- | Two matrices are equal, if and only if their respective canonic representations
-- as rows of rows are equal.

instance (Mapping o, Mapping i, Eq a) => Eq (ParaMatrix rs o i a) where

  (==) = (==) `on` toMat

instance (Functor o, Functor i) => Functor (ParaMatrix rs o i) where

  fmap f = ParaMatrix . fmap (fmap f) . matrix

-- | Pretty-prints a matrix.
-- Each row is represented as @i : (k1 | v1) ... (kr | vr)@,
-- where @(ki, vi)@ are the key-value pairs in the underlying association list.

instance (Mapping o, Mapping i, Show a) => Show (ParaMatrix rs o i a) where

  show = intercalate "\n" . map f . toMat where

    f (j, r)        = unwords [show j, ":", unwords (map showElem r)]

    showElem (i, a) = concat ["(", unwords [show i, "|", show a], ")"]

-- | Transforms a matrix into its canonic representation as a row of rows.

toMat :: (Mapping o, Mapping i) => ParaMatrix rs o i a -> Mat a
toMat = map (fmap toRow) . toRow . matrix

-- | Transforms a row of rows into a matrix.
-- Note that this removes duplicate entries,
-- so that @'fromMat' . toMat' = 'id'@ holds,
-- but @'toMat' . 'fromMat' = 'id'@ is not true in general.

fromMat :: (Mapping o, Mapping i) => Mat a -> ParaMatrix rs o i a
fromMat = fromMappings . map (fmap fromRow)

-- | Transforms a list of indexed 'Mapping's into a matrix.

fromMappings :: Mapping o => [Arc (i a)] -> ParaMatrix rs o i a
fromMappings = ParaMatrix . fromRow

-- | Auxiliary function that applies a supplied combinator to the collections inside the
-- matrix parameters and wraps the result in a 'ParaMatrix' wrapper again.

combineWith :: (o (i a) -> p (j b) -> q (k c)) 
            -> ParaMatrix rs o i a -> ParaMatrix rs' p j b -> ParaMatrix rs'' q k c
combineWith f (ParaMatrix ma) (ParaMatrix mb) = ParaMatrix (f ma mb)

-- | Checks whether a given matrix is empty. 
-- To determine that we check, whether all inner mappings are empty.
-- Note that this is conceptually different from checking for an empty outer layer.

isEmptyMatrix :: (Foldable o, Mapping i) => ParaMatrix rs o i a -> Bool
isEmptyMatrix = F.all isEmpty . matrix

-- | Maps a row transformation function that depends on keys over the matrix.

rowMapWithKey :: KeyFunctor o => 
  (Int -> i a -> j b) -> ParaMatrix rs o i a -> ParaMatrix rs' o j b
rowMapWithKey f = ParaMatrix . fmapWithKey f . matrix

-- | Maps a row transformation function over the matrix.

rowMap :: Functor o => (i a -> j b) -> ParaMatrix rs o i a -> ParaMatrix rs' o j b
rowMap f = ParaMatrix . fmap f . matrix

-- | Filters the values in a matrix with respect to a given predicate.

filterMatrix :: (Functor o, KeyMaybeFunctor i) => 
  (a -> Bool) -> ParaMatrix rs o i a -> ParaMatrix rs o i a
filterMatrix p = ParaMatrix . fmap (ffilter p) . matrix

-- | Filters all occurrences of 'zero' in case of a structure with a notion of a zero element.

removeZeroesMatrix :: (Functor o, KeyMaybeFunctor i, FindZero ma) => 
  ParaMatrix rs o i ma -> ParaMatrix rs o i ma
removeZeroesMatrix = filterMatrix isNotZero

-- | Returns the specified row of a matrix.
-- The result is 'empty', if the given row is not explicitly filled in the matrix.

(!!!) :: (Lookup o, MappingV i) => ParaMatrix rs o i a -> Key -> i a
(!!!) = maybeAt empty . matrix

-- | Returns the value at a given position.
-- If said position is not filled, the supplied element is returned.
-- The first position argument denotes the row and the second one denotes the column.

mAtZ :: (Lookup o, MappingV i) => a -> ParaMatrix rs o i a -> Key -> Key -> a
mAtZ z m i = maybeAt z (m !!! i)

mAt :: (Lookup o, MappingV i, MonoidA a) => ParaMatrix rs o i a -> Key -> Key -> a
mAt = mAtZ zero

-- | Returns the list of the row numbers in the matrix.

rowNumbers :: Mapping o => ParaMatrix rs o i a -> [Key]
rowNumbers = keys . matrix

-- | Returns the number of rows of a matrix.

rowDimension :: Mapping o => ParaMatrix rs o i a -> Int
rowDimension = length . rowNumbers

emptyMatrix :: (Functor o, MappingV i) => ParaMatrix rs o i a -> ParaMatrix rs' o i b
emptyMatrix = ParaMatrix . fmap (const empty) . matrix

-- | An abstraction of the vector-matrix multiplication pattern.
-- The two functions denote abstractions of a vector sum and a scalar multiplication
-- respectively.
-- The scalar multiplication is used in an intersection operation and the sum function is
-- applied to the result of the intersection operation.

vecMatMult :: Intersectable t q => (t c -> d)                    -- ^ sum
                                -> (Key -> a -> i b -> c)        -- ^ scalar multiplication
                                -> t a -> ParaMatrix rs q i b -> d
vecMatMult fSum fMult vec = fSum . intersectionWithKey fMult vec . matrix

-- | A fully parametric abstraction of vector-matrix multiplication.
-- The type class summarises all necessary constraints and provides a default definition of
-- a multiplication generator that depends on value operations only.
-- The supplied definition can be overwritten for efficiency.
-- The function 'mkVMMWith' should satisfy
-- 
-- [/vector-matrix multiplication/]
--  @'mkVMMWith' p t = 'vecMatMult' ('bigunionWith' p 'empty') ('smultWithKey' t)@

class (Foldable vec1, Intersectable vec1 q, Mapping vec2, Unionable vec2 vec3, MappingV vec3)
        => HasHetVMM vec1 q vec2 vec3 where

  mkVMMWith :: (c -> c -> c)              -- ^ addition
            -> (Key -> a -> b -> c)       -- ^ scalar multiplication
            -> vec1 a  
            -> ParaMatrix rs q vec2 b
            -> vec3 c
  mkVMMWith p t = vecMatMult (bigunionWith p empty) (smultWithKey t)

instance HasHetVMM AList  AList     AList  AList
instance HasHetVMM AList  IntMap    AList  AList
instance HasHetVMM IntMap IntMap    IntMap IntMap
instance HasHetVMM AList  SafeArray AList  AList
instance HasHetVMM AList  SafeArray AList  IntMap
instance HasHetVMM AList  SafeArray IntMap IntMap
instance HasHetVMM IntMap SafeArray AList  AList
instance HasHetVMM IntMap SafeArray AList  IntMap
instance HasHetVMM IntMap SafeArray IntMap IntMap

-- | In many cases the result of vector-matrix multiplications should have the same type as
-- the input vector.
-- In these cases one usually also has the property that the same container type is used for
-- the inner layers of the matrix.
-- We abbreviate this variation of the 'HasHetVMM' type class in a new homogeneous type class.

class HasHetVMM vec q vec vec => HasVMM vec q

instance HasVMM AList  AList
instance HasVMM AList  IntMap
instance HasVMM AList  SafeArray
instance HasVMM IntMap IntMap
instance HasVMM IntMap SafeArray

-- | The canonic implementation of the usual vector-matrix multiplication over semirings.
-- The result vector may contain zeroes.

(.*) :: (HasHetVMM vec1 q vec2 vec3, Semiring s) => vec1 s -> ParaMatrix rs q vec2 s -> vec3 s
(.*) = mkVMMWith (.+.) (const (.*.))

-- | An improved implementation of the vector-matrix multiplication over semirings.
-- The result vector does not contain any zero entries.
-- Also, the scalar multiplication is optimised to check for constants first.

(.**) :: (HasHetVMM vec1 q vec2 vec3, MappingV vec2, Semiring s, FindZero s, FindOne s) => 
  vec1 s -> ParaMatrix rs q vec2 s -> vec3 s
(.**) = removeZeroes <.> vecMatMult (bigunionWith (.+.) empty) (const (*>))

-- Lift a vector-matrix multiplication to the matrix level by successively applying it to
-- all the rows.
-- Note that while the suffix suggests a vector-matrix multiplication,
-- the second argument of the supplied function is arbitrary.

liftVecMatMult :: Functor o => 
  (i a -> b -> i' c) -> ParaMatrix rs o i a -> b -> ParaMatrix rs' o i' c
liftVecMatMult (.*) a b = rowMap (.* b) a

-- | A fully parametric matrix multiplication.
-- In the particular case of a homogeneous vector-matrix multiplication setting
-- (i.e. 'HasVMM'),
-- this function can be used to provide a multiplicative monoid instance for matrices.
-- However, since the matrix size is encoded in the matrix type,
-- it is not possible to use the monoid operation on arbitrary matrices.

(.**.) :: (Functor o, HasHetVMM vec1 q vec2 vec3, Semiring s) =>
  Matrix rs o vec1 s -> Matrix rs' q vec2 s -> Matrix rs o vec3 s
(.**.) = liftVecMatMult (.*)

-- | A fully parametric matrix addition.
-- In the particular case of a homogeneous setting (i.e. @rs1 ~ rs2 ~ rs3@ and @t ~ i@)
-- this function can be used to provide an additive monoid instance for matrices.
-- However, this function is more general than the special case,
-- because the type-level size allows application of the monoid operation only in the case of
-- equality.

(.++.) :: (Unionable t i, Unionable vec vec, MonoidA am) =>
  Matrix rs1 t vec am -> Matrix rs2 i vec am -> Matrix rs2 i vec am
(.++.) = unionWith (.+.)

-- | Creates a scalar multiplication from a combination function.
-- The combination function takes the \"outer\" key of the value the mapping is scaled with
-- and also the \"inner\" keys of the individual filled positions.

smultWithKeys :: Mapping m => (Key -> a -> Key -> b -> c) -> Key -> a -> m b -> m c
smultWithKeys op = fmapWithKey <.> op

-- | A variant of 'smultWithKeys' that ignores the inner keys.

smultWithKey :: Mapping m => (Key -> a -> b -> c) -> Key -> a -> m b -> m c
smultWithKey op = smultWithKeys (const <.> op)

-- | The intersection of matrices is an intersection on the
-- outer level followed by an intersection on each inner level.
-- Since matrices are intended to have contiguous key areas,
-- this operation is similar to a 'zipWith' on the outer layer.
-- The class constraints reflect the need for two different kinds of intersection
-- and can be considered canonic.

instance (Intersectable tOuter qOuter, Intersectable tInner qInner) 
  => Intersectable (ParaMatrix rs tOuter tInner) (ParaMatrix rs' qOuter qInner) where

  intersectionWithKey = combineWith . intersectionWith . intersectionWithKey

-- | The union of matrices is a union on the outer level
-- followed by a union on each inner level.
-- However, since unions are homogeneous in the contained types,
-- the inner unions are homogeneous as well.

instance (Unionable tOuter iOuter, Unionable tInner tInner) 
  => Unionable (ParaMatrix rs tOuter tInner) (ParaMatrix rs' iOuter tInner) where

  unionWith = combineWith . unionWith . unionWith

-- | The relative difference of two matrices is the relative difference of each individual row.
-- The outer operation is rather a union (or intersection) than a complement.
-- This behaviour is achieved by using a special difference on the outer level
-- that yields 'Just' results in every possible application of a proper difference operation
-- to rows.

instance (Complementable tOuter quOuter, Complementable tInner quInner)
         => Complementable (ParaMatrix rs tOuter tInner) (ParaMatrix rs' quOuter quInner) where

  differenceWith  op = combineWith (differenceWith (Just <.> differenceWith op))
  differenceWith2 op = combineWith (differenceWith2 (Just <.> differenceWith2 op))

-- | Matrices with traversable outer levels and traversable inner levels that support
-- homogeneous set operations also support set operations.

instance (SetOps tOuter quOuter, SetOps tquInner tquInner) 
  => SetOps (ParaMatrix rs tOuter tquInner) (ParaMatrix rs' quOuter tquInner)

-- | An additive monoid instance for matrices over additive monoids.
-- The addition is the component-wise addition and the zero matrix is a matrix whose
-- rows are empty.
-- Note that the type level natural @rs@ provides the proper size.

instance (UnionableHom o, Mapping o, UnionableHom i, Mapping i, MonoidA ma, KnownNat rs) 
  => MonoidA (ParaMatrix (Proxy rs) o i ma) where
    
  (.+.) = (.++.)
  zero  = fromMat (zip [0..] (genericReplicate (natVal (Proxy :: Proxy rs)) []))

instance (UnionableHom o, Mapping o, UnionableHom i, Mapping i, GroupA ga, FindZero ga, KnownNat rs)
  => GroupA (ParaMatrix (Proxy rs) o i ga) where

  inverseA = filterMatrix isNotZero . fmap inverseA
  a .-. b  = filterMatrix isNotZero (a .+. inverseA b)

instance (Mapping o, HasVMM i o, Semiring s, KnownNat rs)
  => MonoidM (ParaMatrix (Proxy rs) o i s) where
  
  (.*.) = (.**.)
  one   = fromMappings [(i, unitVector i) | i <- [0 .. fromInteger (natVal (Proxy :: Proxy rs)-1)]]